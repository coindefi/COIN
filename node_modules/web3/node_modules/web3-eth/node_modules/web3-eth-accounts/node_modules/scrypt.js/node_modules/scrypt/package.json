{
  "name": "scrypt",
  "description": "The scrypt crypto library for NodeJS",
  "version": "6.0.3",
  "license": "zlib",
  "keywords": [
    "scrypt",
    "password",
    "auth",
    "authentication",
    "encryption",
    "crypto",
    "secret",
    "key",
    "secret key",
    "hash",
    "verify"
  ],
  "author": {
    "name": "Barry Steyn",
    "email": "barry.steyn@gmail.com",
    "url": "http://doctrina.org"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/barrysteyn/node-scrypt.git"
  },
  "devDependencies": {
    "mocha": "2.2.5",
    "chai": "3.0.0",
    "chai-as-promised": "^5.1.0"
  },
  "dependencies": {
    "nan": "^2.0.8"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "bugs": {
    "url": "https://github.com/barrysteyn/node-scrypt/issues"
  },
  "scripts": {
    "preinstall": "node node-scrypt-preinstall.js",
    "install": "node-gyp rebuild",
    "test": "mocha tests/scrypt-tests.js"
  },
  "readme": "# Scrypt For Node\n\n[![Build Status](https://travis-ci.org/barrysteyn/node-scrypt.png?branch=master)](https://travis-ci.org/barrysteyn/node-scrypt)\n[![npm version](https://badge.fury.io/js/scrypt.svg)](http://badge.fury.io/js/scrypt)\n\nScrypt for Node/IO is a native node/io C++ wrapper for Colin Percival's\n[scrypt](https://www.tarsnap.com/scrypt.html) cryptographic hash utility.\n\nAs should be the case with any security tool, this library should be scrutinized\nby anyone using it. If you find or suspect an issue with the code- please bring\nit to my attention and I'll spend some time trying to make sure that this tool is\nas secure as possible.\n\n## Node-Scrypt Version 6\nVersion 6 is a major new release. It is by and large compatible with version 5.\n \n  * Scrypt version 1.2.0 is being used (a very recently released version of Scrypt)\n  * Using Node's internal cryptographic libraries - for windows users, there is no need to use an external OpenSSL library anymore.\n  * Using Node's OS module to check for freemem, meaning no need to use any system calls and therefore no external dependencies\n\nVersion 6 should work much better on all platforms\n\n## Past Releases\n### Node-Scrypt Version 5\nVersion 5 is a major new release that is **not backward compatible** with any\nprevious version. Some highlights:\n\n  * C++ addon code rewritten:\n    * Using [Nan 2.x](https://github.com/nodejs/nan)\n    * Code has been greatly simplified\n  * ES6 Promise aware.\n  * API has changed:\n    * Every output is a buffer.\n    * Separated functions into async and sync versions.\n    * Api name swap: What was kdf in previous versions is now hash (and vice versa).\n    * Async functions will return a Promise if no callback function is present and Promises are available (else it will throw a SyntaxError).\n  * Using correct [JavaScript Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object for all errors.\n\n### Migrating To Version 5\nVersion 5 is not backward compatible, but it should still be easy to migrate.\nPlease read the [api section](#api) to see what's changed. One big change that is\nworth noting is a name change: What used to be called **hash** has now been\nchanged to **kdf** and conversely, what was **kdf** is now called **hash**.\n\n## Table Of Contents\n\n * [Scrypt](#scrypt)\n * [Installation Instructions](#installation-instructions)\n * [API](#api) - The module consists of four functions:\n   * [params](#params) - a translation function that produces scrypt parameters\n   * [kdf](#kdf) - a key derivation function designed for password hashing\n   * [verifyKdf](#verifykdf) - checks if a key matches a kdf\n   * [hash](#hash) - the raw underlying scrypt hash function\n * [Example Usage](#example-usage)\n * [FAQ](#faq)\n * [Roadmap and Changelog](#roadmap)\n * [Credits](#credits)\n\n# Scrypt\nScrypt is an advanced crypto library used mainly for [key derivation](http://en.wikipedia.org/wiki/Key_derivation_function):\nMore information can be found here:\n\n* [Tarsnap blurb about scrypt](http://www.tarsnap.com/scrypt.html) - Colin Percival\n(the author of scrypt) explains a bit about it.\n* [Academic paper explaining scrypt](http://www.tarsnap.com/scrypt/scrypt.pdf).\n* [Wikipedia Article on scrypt](http://en.wikipedia.org/wiki/Scrypt).\n\n# Installation Instructions\n\n## Pre-Requisistes\n### Windows\n\n * [Node-Gyp](https://github.com/TooTallNate/node-gyp) for Windows:\n   * Installation instructions: [node-gyp for windows](https://github.com/TooTallNate/node-gyp#installation)\n   * Look [here](https://github.com/TooTallNate/node-gyp/wiki/Visual-Studio-2010-Setup) for additional information/helpful hints.\n\n### Linux/MacOS\n[Node-gyp](https://github.com/TooTallNate/node-gyp) is needed to build this module. It should be installed globally, that is, with the `-g` switch:\n\n    npm install -g node-gyp\n\n## Install From NPM\n\n    npm install scrypt\n\n## Install From Source\n\n    git clone https://github.com/barrysteyn/node-scrypt.git\n    cd node-scrypt\n    npm install\n    node-gyp configure build\n\n## Testing\nTo test, go to the folder where scrypt was installed, and type:\n\n    npm test\n\n# API\n\n## params\nTranslates human understandable parameters to scrypt's internal parameters.\n\n>\n  scrypt.paramsSync <br>\n  scrypt.params(maxtime, [maxmem, [max_memfrac]], [function(err, obj) {}])\n\n  * maxtime - [REQUIRED] - a decimal (double) representing the maximum amount of time in seconds scrypt will spend when computing the derived key.\n  * maxmem - [OPTIONAL] - an integer, specifying the maximum number of bytes of RAM used when computing the derived encryption key. If not present, will default to 0.\n  * maxmemfrac - [OPTIONAL only if maxmem is present] - a double value between 0.0 and 1.0, representing the fraction (normalized percentage value) of the available RAM used when computing the derived key. If not present, will default to 0.5.\n  * callback_function - [OPTIONAL] - not applicable to synchronous function. If present in async function, then it will be treated as a normal async callback. If not present, a Promise will be returned if ES6 promises are available. If not present and ES6 promises are not present, a SyntaxError will be thrown.\n\n## kdf\n**Note**: In previous versions, this was called *hash*.\n\nProduces a key derivation function that uses the scrypt hash function. This\nshould be used for hashing and checking passwords as it incorporates salt as well\nas [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) into\nits format. It is based on a design by Colin Percival, the author of scrypt. The format\ncan be seen [here](http://security.stackexchange.com/questions/88678/why-does-node-js-scrypt-function-use-hmac-this-way/91050#91050).\n\n>\n  scrypt.kdfSync <br>\n  scrypt.kdf(key, paramsObject, [function(err, obj){}])\n\n  * key - [REQUIRED] - a string (or buffer) representing the key (password) that is to be hashed.\n  * paramsObject - [REQUIRED] - parameters to control scrypt hashing (see params above).\n  * callback_function - [OPTIONAL] - not applicable to synchronous function. If present in async function, then it will be treated as a normal async callback. If not present, a Promise will be returned if ES6 promises are available. If not present and ES6 promises are not present, a SyntaxError will be thrown.\n\n## verifyKdf\n\nChecks if a key (password) matches a kdf.\n\n>\n  scrypt.verifyKdfSync <br>\n  scrypt.verifyKdf(kdf, key, [function(err, result){}])\n\n * kdf [REQUIRED] - see kdf above.\n * key - [REQUIRED] - a string (or buffer) representing the key (password) that is to be checked.\n * callback_function - [OPTIONAL] - not applicable to synchronous function. If present in async function, then it will be treated as a normal async callback. If not present, a Promise will be returned if ES6 promises are available. If not present and ES6 promises are not present, a SyntaxError will be thrown.\n\n## hash\n**Note**: In previous versions, this was called *kdf*.\n\nThis is the raw scrypt hash function.\n\n>\n  scrypt.hashSync <br>\n  scrypt.hash(key, paramsObject, output_length, salt, function(err, obj){})\n\n  * key - [REQUIRED] - a string (or buffer) representing the key (password) that is to be checked.\n  * paramsObject - [REQUIRED] - parameters to control scrypt hashing (see params above).\n  * output_length - [REQUIRED] - the length of the resulting hashed output.\n  * salt - [REQUIRED] - a string (or buffer) used for salt. The string (or buffer) can be empty.\n  * callback_function - [OPTIONAL] - not applicable to synchronous function. If present in async function, then it will be treated as a normal async callback. If not present, a Promise will be returned if ES6 promises are available. If not present and ES6 promises are not present, a SyntaxError will be thrown.\n\n# Example Usage\n\n## params\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\n\n//Synchronous\ntry {\n  //Uses 0.1 for maxtime, and default values maxmem and maxmemfrac\n  var scryptParameters = scrypt.paramsSync(0.1);\n  console.log(scryptParameters);\n} catch(err) {\n  //handle error\n}\n\n//Asynchronous with callback\nscrypt.params(0.1, function(err, scryptParameters) {\n  console.log(scryptParameters);\n});\n\n//Asynchronous with promise\nscrypt.params(0.1).then(function(result){\n  console.log(result);\n}, function(err) {\n  console.log(err);\n});\n```\n\n## kdf\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\nvar scryptParameters = scrypt.paramsSync(0.1);\nvar key = new Buffer(\"this is a key\"); //could also be a string\n\n//Synchronous example that will output in hexidecimal encoding\nvar kdfResult = scrypt.kdfSync(key, scryptParameters); //should be wrapped in try catch, but leaving it out for brevity\nconsole.log(\"Synchronous result: \"+kdfResult.toString(\"hex\"));\n\n//Asynchronous example that expects key to be ascii encoded\nscrypt.kdf(\"ascii encoded key\", {N: 1, r:1, p:1}, function(err, result){\n  //Note how scrypt parameters was passed as a JSON object\n  console.log(\"Asynchronous result: \"+result.toString(\"base64\"));\n});\n\n//Asynchronous with promise\nscrypt.kdf(\"ascii encoded key\", {N: 1, r:1, p:1}).then(function(result){\n  console.log(\"Asynchronous result: \"+result.toString(\"base64\"));\n}, function(err){\n});\n```\n\n## verifyKdf\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\nvar scryptParameters = scrypt.paramsSync(0.1);\nvar kdfResult = scrypt.kdfSync(\"password\", scryptParameters);\n\n//Synchronous\nscrypt.verifyKdfSync(kdfResult, \"password\"); // returns true\nscrypt.verifyKdfSync(kdfResult, \"incorrect password\"); // returns false\n\n//Asynchronous\nscrypt.verifyKdf(kdfResult, new Buffer(\"password\"), function(err, result) {\n  //result will be true\n});\n\n//Asynchronous with promise\nscrypt.verifyKdf(kdfResult, \"incorrect password\").then(function(result) {\n  //result will be false\n}, function(err) {\n});\n```\n\n## hash\nThe [scrypt paper](http://www.tarsnap.com/scrypt/scrypt.pdf) lists four [test vectors](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00#page-11) to test implementation. This example will show how to produce these test vectors from within this module.\n\n### Test Vector 1\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\nvar key = new Buffer(\"\");\n\n//Synchronous\nvar result = scrypt.hashSync(key,{\"N\":16,\"r\":1,\"p\":1},64,\"\");\nconsole.log(result.toString(\"hex\"));\n\n//Asynchronous\nscrypt.hash(key, {\"N\":16,\"r\":1,\"p\":1},64,\"\", function(err, res) {\n  console.log(result.toString(\"hex\"));\n});\n\n//Asynchronous with promise\nscrypt.hash(key, {\"N\":16,\"r\":1,\"p\":1},64,\"\").then(function(result) {\n  console.log(result.toString(\"hex\"));\n}, function(err){});\n```\n\n### Test Vector 2\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\nvar salt = new Buffer(\"NaCl\");\n\n//Synchronous\nvar result = scrypt.hashSync(\"password\", {\"N\":1024,\"r\":8,\"p\":16}, 64, salt);\nconsole.log(result.toString(\"hex\"));\n\nscrypt.hash(\"password\", {\"N\":1024,\"r\":8,\"p\":16},64,salt, function(err, result) {\n  console.log(result.toString(\"hex\"));\n});\n```\n\n### Test Vector 3\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\nvar key = new Buffer(\"pleaseletmein\");\nvar salt = new Buffer(\"SodiumChloride\");\n\n//Synchronous\nvar result = scrypt.hashSync(key,{\"N\":16384,\"r\":8,\"p\":1},64,salt);\nconsole.log(result.toString(\"hex\"));\n\n//Asynchronous\nscrypt.hash(key, {\"N\":16384,\"r\":8,\"p\":1}, 64, salt, function(err, result) {\n  console.log(result.toString(\"hex\"));\n});\n```\n\n### Test Vector 4\nNote: This test vector is very taxing in terms of resources.\n\n```JavaScript\nvar scrypt = require(\"scrypt\");\n\n//Synchronous\nvar result = scrypt.hashSync(\"pleaseletmein\",{\"N\":1048576,\"r\":8,\"p\":1},64,\"SodiumChloride\");\nconsole.log(result.toString(\"hex\"));\n\n//Asynchronous\nscrypt.hash(\"pleaseletmein\", {\"N\":1048576,\"r\":8,\"p\":1},64,\"SodiumChloride\", function(err, result) {\n  console.log(result.toString(\"hex\"));\n});\n```\n\n# FAQ\n## General\n### What Platforms Are Supported?\nThis module supports most posix platforms, as well as Microsoft Windows. It has been tested on the\nfollowing platforms: **Linux**, **MAC OS**, **SmartOS** (so its ready for Joyent Cloud)\nand **Microsoft Windows**. It also works on FreeBSD, OpenBSD, SunOS etc.\n\n## Scrypt\n### Why Use Scrypt?\n\nIt is probably the most advanced key derivation function available. This is is quote taken\nfrom a comment in hacker news:\n\n>Passwords hashed with scrypt with sufficiently-high strength values (there are 3 tweakable\ninput numbers) are fundamentally impervious to being cracked. I use the word \"fundamental\"\nin the literal sense, here; even if you had the resources of a large country, you would not\nbe able to design any hardware (whether it be GPU hardware, custom-designed hardware, or\notherwise) which could crack these hashes. Ever. (For sufficiently-small definitions of\n\"ever\". At the very least \"within your lifetime\"; probably far longer.)\n\n### What Are The Pros And Cons For Using Scrypt?\n#### Pros\n\n* The scrypt algorithm has been published by [IETF](http://en.wikipedia.org/wiki/IETF)\nas an [Internet Draft](http://en.wikipedia.org/wiki/Internet_Draft) and is thus on track to becoming a standard. See [here](https://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00) for the draft.\n* It is being actively used in production at [Tarsnap](http://www.tarsnap.com/).\n* It is much more secure than bcrypt.\n* It is designed to be future proof against attacks with future (and more advanced) hardware.\n* It is designed to defend against large scale custom hardware attacks.\n* It is production ready.\n* There is a scrypt library for most major scripting languages\n(Python, Ruby etc). Now this module provides the library for NodeJS :)\n\nI will end this section with a quote from Colin Percival (author of scrypt):\n\n> We estimate that on modern (2009) hardware, if 5 seconds are spent computing a derived key,\nthe cost of a hardware brute-force attack against scrypt is roughly 4000 times greater than the\ncost of a similar attack against bcrypt (to find the same password), and 20000 times greater\nthan a similar attack against PBKDF2.\n\n#### Cons\nThere is just one con I can think of: It is a relatively new library (only been around since 2009).\nCryptographers don't really like new libraries for production deployment as it has not been *battle\ntested*. That being said, it is being actively used in [Tarsnap](http://www.tarsnap.com/)\n(as mentioned above) and the author is very active.\n\n## Using Scrypt With Passwords\n### What Are The Essential Properties For Storing Passwords?\nStoring passwords requires three essential properties\n\n* The password must not be stored in plaintext.\n* The password hash must be salted. (Making a rainbow table attack very\ndifficult to pull off).\n* The salted hash function must not be fast. (If someone does get hold\nof the salted hashes, their only option will be brute force which will\nbe very slow).\n\nAs an example of how storing passwords can be done badly, take [LinkedIn](http://www.linkedin.com).\nIn 2012, they [came under fire](http://thenextweb.com/socialmedia/2012/06/06/bad-day-for-linkedin-6-5-million-hashed-passwords-reportedly-leaked-change-yours-now/#!rS1HT)\nfor using unsalted hashes to store their passwords. As most commentators at\nthe time were focusing no salt being present, the big picture was missed.\nIn fact, their biggest problem was that they used [sha1](http://en.wikipedia.org/wiki/SHA-1),\na very fast hash function.\n\n### If random salts are used, why do all resulting KDF's start with *c2NyeXB0*?\nThe kdf has a [specific format](http://security.stackexchange.com/questions/88678/why-does-node-js-scrypt-function-use-hmac-this-way/91050#91050):\nThe word *\"scrypt\"* is added as a prefix. The reason for this is because\nI am sticking to Colin Percival's (the creator of scrypt) reference implementation,\nwhereby he prefixes *scrypt* in this way. The base64 encoding of the ascii *\"scrypt\"*\nis *c2NyeXB0*. The scrypt parameters are then appended. Users of scrypt normally do\nnot change this information once it is settled upon (hence this will also look the\nbe identical).\n\n\nTo illustrate with an example, I have hashed two password: *password1* and *password2*.\nTheir Base64 outputs are as follows:\n\n    password1\n    c2NyeXB0AAwAAAAIAAAAAcQ0zwp7QNLklxCn14vB75AYWDIrrT9I/7F9+lVGBfKN/1TH2hs\n    /HboSy1ptzN0YzHJhC7PZIEPQzf2nuoaqVZg8VkKEJlo8/QaH7qjU2VwB\n\n    password2\n    c2NyeXB0AAwAAAAIAAAAAZ/+bp8gWcTZgEC7YQZeLLyxFeKRRdDkwbaGeFC0NkdUr/YFAWY\n    /UwdOH4i/PxW48fXeXBDOTvGWtS3lLUgzNM0PlJbXhMOGd2bke0PvTSnW\n\nAs one can see from the above example, both hashes start off by looking similar (they both start\nwith *c2NyeXB0AAwAAAAIAAAAA* - as explained above), but after this, things change very rapidly.\nIn fact, I hashed the password *password1* again:\n\n    password1\n    c2NyeXB0AAwAAAAIAAAAATpP+fdQAryDiRmCmcoOrZa2mZ049KdbA/ofTTrATQQ+m\n    0L/gR811d0WQyip6p2skXVEMz2+8U+xGryFu2p0yzfCxYLUrAaIzaZELkN2M6k0\n\nCompare this hash to the one above. Even though they start off looking similar, their outputs\nare vastly different (even though it is the same password being hashed). This is because of\nthe **random** salt that has been added, ensuring that no two hashes will ever be identical,\neven if the password that is being hashed is the same.\n\nFor those that are curious or paranoid, please look at how the kdf is both [produced](https://github.com/barrysteyn/node-scrypt/blob/master/src/scryptwrapper/keyderivation.c#L36-L80)\nand [verified](https://github.com/barrysteyn/node-scrypt/blob/master/src/scryptwrapper/keyderivation.c#L82-L121) (you are going to need some knowledge of the [C language](http://c.learncodethehardway.org/book/) for this).\n\n# Roadmap\nSee [changelog](https://github.com/barrysteyn/node-scrypt/blob/master/changelog.md) for upcoming features.\n\n# Credits\nThe scrypt library is Colin Percival's [scrypt](http://www.tarsnap.com/scrypt.html) project.\n\nSyed Beparey was instrumental in getting the Windows build working, with most of the Windows build based off the work done by Dinesh Shanbhag.\n",
  "readmeFilename": "README.md",
  "_id": "scrypt@6.0.3",
  "dist": {
    "shasum": "b856325195e9514e3668ca74c33f844c75f97ab7"
  },
  "_from": "scrypt@^6.0.2",
  "_resolved": "https://registry.npmjs.org/scrypt/-/scrypt-6.0.3.tgz"
}
